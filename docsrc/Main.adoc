== Main module

Elm programming dictates the use of a fair number of packages and instead of
sprinkling the import statements throughout this section they are presented
here so that function and type documentation is more readable.

The https://package.elm-lang.org/packages/mdgriffith/elm-animator/latest/[elm-animator]
package has been chosen for animation.

[source,elm]
----
<<main-imports>>=
import Animator
import Time
----

Here we import all of the
https://package.elm-lang.org/packages/orus-io/elm-nats/latest/[elm-nats]
packages needed for web socket communication.
The `Random` package is here because it is used in <<main-init,init>>
when a subscription to NATS is started.

[source,elm]
----
<<main-imports>>=
import Nats
import Nats.Config
import Nats.Effect
import Nats.Events
import Nats.PortsAPI
import Nats.Protocol
import Nats.Socket
import Nats.Sub
import Random
----

https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/[elm-ui] is
used for layout and UI design.

[source,elm]
----
<<main-imports>>=
import Element as E
import Element.Background as Background
import Element.Border as Border
import Color
----

Using https://package.elm-lang.org/packages/orus-io/elm-orus-ui/latest/[elm-orus-ui],
a UI toolkit modeled after the Material Design System, provides reasonable
theme coloring without too much hassle.

[source,elm]
----
<<main-imports>>=
import OUI.Button as Button
import OUI.Icon as Icon
import OUI.Material as Material
import OUI.Material.Color
import OUI.Material.Theme
import OUI.Menu
import OUI.MenuButton
import OUI.Text as Text
----

For animated graphics, structured vector graphics (SVG) are employed.
[source,elm]
----
<<main-imports>>=
import Svg exposing (Svg)
import Svg.Attributes as SvgA
----

NOTE: Not all links for packages used in this application are annotated in
this document. Please peruse the absolute source, the local `elm.json` file,
for every package used. All elm packages can be found in the
https://package.elm-lang.org/[Elm package catalog].

(((Main,port module)))

`NATS` communiction in Elm is accomplished with web sockets. This is fairly
well hidden from us but the first order of business is to indicate to `elm`
that we will be expecting a port to be set up in the `index.html` file by
declaring `Main` a port module. Note that only a single function is exposed by
the `Main` module.

(((Main,port module)))
[source,elm]
----
<<main-module>>=
port module Main exposing (main)
----

This is an `elm` browser document which requires us to declare various
functions that will inform the architecture how it is going to deal with the
state (`Model`) of our application.

<<main-view,view>>:: The assembly of the graphical parts and their layout.
<<main-init,init>>:: Initialization of the model
<<main-update,update>>:: When messages arrive, they are handled here. For a NATS
  application this function has a wrapper to check to see if a message arrived
  on the port before calling into the proper update function.
<<main-subscriptions,subscriptions>>:: Look here to see how we subscribe to NATS
  messages and animation timers.

Think of this in this way. The `update` function is, literally, where all the
action takes place. Any message defined on the `Model` must be accounted for
in `update`. Once updated, the `view` function is called to read the DOM
hierarchy and make sure any graphical updates are made.

`wetselm` will need the following packages as a minimum to accomplish this.

(((Main,imports)))

[source,elm]
----
<<main-imports>>=
import Browser
import Wets
import UI
import Util
----

The main entry point is called `main` in this module and describes a jump
table telling the elm run-time how the
https://package.elm-lang.org/packages/elm/browser/latest/[Browser]
is to be built.

[source,elm]
----
<<main-functions>>=
main : Program { now : Int } Model Msg
main =
    Browser.document
        { view = view
        , init = init
        , update = wrappedUpdate
        , subscriptions = subscriptions
        }
----

A _wrapped_ update is used so the arriving NATS messages can be inserted into
the _update_ functionality. Take a look at the
<<main-wrapped-update,wrappedUpdate>> function for more detail.

The <<main-subscriptions,subscriptions>> function is necessary for both
message handling and animation.


=== Model [[main-model]]

The `Model` type alias is used within the Elm architecture to declare the
state of the application in record form.

(((Main,type,Model)))

[source,elm]
----
<<main-types>>=
type alias Model =
    { nats : Nats.State String Msg
    , socket : Nats.Socket.Socket
    , serverInfo : Maybe Nats.Protocol.ServerInfo
    , actuatorStates : Animator.Timeline (Dict Id ActuatorState)
    , chamberStates : Animator.Timeline (Dict Id ChamberState)
    , vesselStates : Animator.Timeline (Dict Id TransitState)
    , wetsPopname : String
    , popState : OUI.MenuButton.State
    , activeVessels : VesselDict
    , vesselCount : Int
    , message : String
    }
----

* For NATS communication we need the `nats`, `socket`, and `serverInfo`
elements.

* The `actuator-`, `chamber-`, and `vessel-` `States` declare the
timelines for animation.

* `wetsPopname` contains the name of the translated information model's
population.

* `popState` is used by the pull-down menu to select and set the WETS
population name.

* The `activeVessels` dictionary helps track the
transit steps.

* `vesselCount` is instrumental in vessel naming

* `message` is used for displaying informational messages.

See the <<main-init,init>> function for how this `model` is initialized.

We use a lot of dictionaries so the import is directed to also expose the `Dict`
type to improve code readability.

[source,elm]
----
<<main-imports>>=
import Dict exposing (Dict)
----

==== init [[main-init]]

This function is directed here from the <<main-main,main>> function and
initializes all elements of the <<main-model,Model>>.

* The _flags_ argument is populated in the `index.html` file as the current
  date and is used as a random seed for initializing NATS.

* Motor-driven animations (valves and gates) are initialized here to their
  population definitions (see the WETS documentation). Note that the naming
  here reflects the naming in the population as well.

* Chambers are animated with the `chamberStates` element.

* The vessel states are initialized to an empty dictionary.

* Messages are initialized to an empty string.

The NATS socket is defined to address the web-socket address defined
in the `server.config` file.

(((Main,functions,init)))

[source,elm]
----
<<main-functions>>=
init : { now : Int } -> ( Model, Cmd Msg )
init flags =
    let
        nats : Nats.State String Msg
        nats = Nats.init (Random.initialSeed flags.now)
             (Time.millisToPosix flags.now)
    in
    ( { actuatorStates =
            Animator.init <|
                Dict.fromList
                    [ ( "Valve-M01", Closed )
                    , ( "Valve-M02", Closed )
                    , ( "Valve-M03", Closed )
                    , ( "Valve-M04", Closed )
                    , ( "Valve-M05", Closed )
                    , ( "Gate-M01", Closed )
                    , ( "Gate-M02", Closed )
                    , ( "Gate-M03", Closed )
                    , ( "Gate-M04", Closed )
                    , ( "Gate-M05", Closed )
                    ]
      , chamberStates =
            Animator.init <|
                Dict.fromList [ ( "AChamber", High )
                              , ( "BChamber", High )
                              ]
      , vesselStates = Animator.init Dict.empty
      , nats = nats
      , socket = Nats.Socket.new "0" "ws://localhost:8087"
      , serverInfo = Nothing
      , wetsPopname = "Wets_1"
      , popState = OUI.MenuButton.init "popmenu"
      , vesselCount = 0
      , activeVessels = Dict.empty
      , message = ""
      }
    , Cmd.none
    )
----

CAUTION: A design decision has been made with regards to vessels. Their state
-- where they are located during transit -- and the vessel instance are
managed separately.


==== ChamberState [[main-chamber-state]]

The number of chambers are defined by the number of gates. Each chamber has a
`High` and `Low` state.

(((Main,types,ChamberState)))

[source,elm]
----
<<main-types>>=
type ChamberState
    = High
    | Low
----


==== ActuatorState [[main-actuator-state]]

Motors (valves and gates) are either `Opened` or `Closed`.

(((Main,types,ActuatorState)))

[source,elm]
----
<<main-types>>=
type ActuatorState
    = Opened
    | Closed
----


.Id [[main-id]]

An `Id` is an alias for a `String` and is meant to delineate identifiers from
plain strings.

(((Main,types,Id)))

[source,elm]
----
<<main-types>>=
type alias Id =
    String
----

=== Vessels

==== TransitState [[main-transit-state]]

A `TransitState` defines positional milestones in a vessels path through a
transit lane. Each vessel will have a specific <<main-transit-sequence,transit
sequence>> that it will traverse either down- or up- stream. The following
diagram shows the vessel milestones for a *Wets_1* (two gates, two valves, one
chamber) system.

.Transit milestones in a vessel's path
image::chamber-layout.svg[]

* The _Entry_ states are offstage (outside the SVG view) positions and not
  meant to be directly viewed by the user. This allows an initial animation from
  offstage to the waiting state.

* The _Chamber_ states are also employed by flow control when determining if a
  vessel is present in a chamber.

(((Main,TransitState)))

[source,elm]
----
<<main-types>>=
type TransitState
    = UpperEntry
    | UpperGate
    | AChamberHigh
    | AChamberLow
    | BChamberHigh
    | BChamberLow
    | LowerGate
    | LowerEntry
    | AtSea
----

==== TransitSequence [[main-transit-sequence]]

This is a list of `TransitState` values and used to define a path along
which a vessel is expected to travel.

(((Main,types,TransitSequence)))

[source,elm]
----
<<main-types>>=
type alias TransitSequence =
    List TransitState
----

==== Vessel [[main-vessel]]

A `Vessel` has a <<main-direction,Direction>> and a
<<main-transit-sequence,TransitSequence>>.
This will be used later as a value for the
<<main-vessel-dict,vessel dictionary>>.

(((Main,types,Vessel)))

[source,elm]
----
<<main-types>>=
type alias Vessel =
    { direction : Util.Direction
    , sequence : TransitSequence
    }
----

==== VesselDict [[main-vessel-dict]]

Declare a type we can use to store `Vessel` objects by name.

(((Main,types,VesselDict)))

[source,elm]
----
<<main-types>>=
type alias VesselDict =
    Dict Id Vessel
----

==== VesselStrategy [[main-vessel-strategy]]

WETS populations define the layout of a canal lock; a _VesselStrategy_
contains the data that will define how a vessel moves through those locks. So
a strategy for each supported population is required.

upSequence:: An ordered list of <<main-transit-state,TransitStates>> that a
vessel will traverse when going upstream.

downSequence:: An ordered list of <<main-transit-state,TransitStates>> that a
vessel will traverse when going downstream.

toPosition:: A function to provide an XY position for each
<<main-transit-state,TransitState>>. These are SVG positions within a SVG
view. See <<main-anim-vessel,animVessel>> for how this is used.

(((main,types,VesselStrategy)))

[source,elm]
----
<<main-types>>=
type alias VesselStrategy =
    { upSequence : TransitSequence
    , downSequence : TransitSequence
    , toPosition : ( TransitState -> Util.Position )
    }
----

.wetsOne [[main-wets-one]]

(((main,Vessel strategies, Wets_1)))

This literal provides the <<main-vessel-strategy,VesselStrategy>> instance for
the WETS population named *Wets_1*.

(((main,literals,wetsOne)))
(((main,literals,Wets_1)))

[source,elm]
----
<<main-literals>>=
wetsOne : VesselStrategy
wetsOne =
    { upSequence =
          [ LowerEntry
          , LowerGate
          , AChamberLow
          , AChamberHigh
          , UpperEntry
          ]
    , downSequence =
        [ UpperEntry
        , UpperGate
        , AChamberHigh
        , AChamberLow
        , LowerEntry
        ]
    , toPosition =
          (\tstate ->
               case tstate of
                   LowerEntry   -> Util.Position 650.0 80.0
                   LowerGate    -> Util.Position 500.0 80.0
                   AChamberLow  -> Util.Position 300.0 80.0
                   AChamberHigh -> Util.Position 300.0 40.0
                   UpperGate    -> Util.Position 100.0 40.0
                   UpperEntry   -> Util.Position -70.0 40.0
                   _ -> Util.Position 0.0 0.0
              )
    }
----

.wetsTwo [[main-wets-two]]

(((main,Vessel strategies, Wets_2)))

For a vessel transiting a *Wets_2* canal lock, there is one more chamber to
traverse. As in the *Wets_1* vessel path, the start and end states are
off-stage to assist in the entry and exit animation. The following diagram
shows a downstream vessel path.

.Transit milestones for Wets_2 [[wets-2-vessel-path-diagram]]
image::wets-2-vessel-path.svg[]

(((main,literals,wetsTwo)))

[source,elm]
----
<<main-literals>>=
wetsTwo : VesselStrategy
wetsTwo =
    { upSequence =
        [ LowerEntry
        , LowerGate
        , AChamberLow, AChamberHigh
        , BChamberLow, BChamberHigh
        , UpperEntry
        ]
    , downSequence =
        [ UpperEntry
        , UpperGate
        , BChamberHigh , BChamberLow
        , AChamberHigh , AChamberLow
        , LowerEntry
        ]
    , toPosition =
        \tstate ->
            case tstate of
                LowerEntry   -> Util.Position 650.0 120.0
                LowerGate    -> Util.Position 525.0 120.0
                AChamberLow  -> Util.Position 375.0 120.0
                AChamberHigh -> Util.Position 375.0 80.0
                BChamberLow  -> Util.Position 225.0 80.0
                BChamberHigh -> Util.Position 225.0 40.0
                UpperGate    -> Util.Position  75.0 40.0
                UpperEntry   -> Util.Position -70.0 40.0
                _ -> Util.Position 0.0 0.0
    }
----

==== wetsPop [[main-wets-pop]]

This is a dictionary that hold <<main-vessel-strategy,strategies>> for all
supported WETS populations.

(((main,literals,wetsPop)))

[source,elm]
----
<<main-literals>>=
wetsPop : Dict String VesselStrategy
wetsPop =
    Dict.fromList
        [ ( "Wets_1", wetsOne )
        , ( "Wets_2", wetsTwo )
        ]
----

==== nextTransition [[next-transition]]

The path of a Vessel is determined by its
<<main-transit-sequence,TransitSequence>>.
The next milestone in a sequence is always at the head of the list. A
https://package.elm-lang.org/packages/elm/core/latest/Maybe[Maybe] type is
used here because the sequence could very well be empty, yielding `Nothing`
from the function.

(((Main,functions,nextTransition)))

[source,elm]
----
<<main-functions>>=
nextTransition : Id -> VesselDict -> Maybe TransitState
nextTransition license vdict =
    Dict.get license vdict
        |> Maybe.andThen (\v -> List.head v.sequence)
----

==== adjustSequence [[main-adjust-sequence]]

When the next milestone in a sequence is reached, the front of the list is
popped off and the <<main-vessel-dict,Vessel's dictionary>> is updated.

(((Main,functions,AdjustSequence)))

[source,elm]
----
<<main-functions>>=
adjustSequence : Id -> VesselDict -> VesselDict
adjustSequence license vdict =
    let
        pophead : Vessel -> Vessel
        pophead v =
            { v | sequence = List.drop 1 v.sequence }
    in
    Dict.update license (Maybe.map pophead) vdict
----

==== newVessel [[main-new-vessel]]

Construct a <<main-vessel,Vessel>> going in a specific direction with
milestones defined by a specific <<main-vessel-strategy,vessel strategy>>. This is
meant to reside as a value in a <<main-vessel-dict,Vessel's dictionary>>.

(((Main,)))
[source,elm]
----
<<main-functions>>=
newVessel : String -> Util.Direction -> Maybe Vessel
newVessel popName dir =
    let
        makeVessel : VesselStrategy -> Vessel
        makeVessel strategy =
            { direction = dir
            , sequence =
                case dir of
                    Util.Upstream ->
                        strategy.upSequence
                    Util.Downstream ->
                        strategy.downSequence
            }
    in
        Maybe.map makeVessel
            <| Dict.get popName wetsPop
----


==== animator [[main-animator]]

The https://package.elm-lang.org/packages/mdgriffith/elm-animator/latest/[elm-animator]
package dictates that an `Animator` literal needs to be defined.
These are better described in the package documentation but, briefly, this
is for telling the animator what timelines are active and how their states are
accessed.

Each `Timeline` in the <<main-model,Model>> is represented here.

(((Main,literals,animator)))

[source,elm]
----
<<main-literals>>=
animator : Animator.Animator Model
animator =
    Animator.animator
        |> Animator.watching
            .actuatorStates
            (\newActuatorStates model ->
                { model | actuatorStates = newActuatorStates}
            )
        |> Animator.watching
            .chamberStates
            (\newChamberStates model ->
                { model | chamberStates = newChamberStates}
            )
        |> Animator.watching
            .vesselStates
            (\newVesselStates model ->
                { model | vesselStates = newVesselStates}
            )
----


.subscriptions [[main-subscriptions]]

There are several subscriptions to declare,

* Messages arriving on the port will trigger a message to <<main-update,update>>.
* Animation ticks on the timeline will trigger update as well.
* One for the pop down menu to act correctly when a button is pressed outside
  the pull-down.

(((main,functions,subscriptions)))

[source,elm]
----
<<main-functions>>=
subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch
        [ Nats.subscriptions natsConfig model.nats
        , Animator.toSubscription AnimationRuntimeStep model animator
        , OUI.MenuButton.onOutsideClick (MenuButtonMsg "popmenu") model.popState
        ]
----

=== Ports

==== natsConfig [[main-nats-config]]

Configure the `Nats` module.

(((main,functions,natsConfig)))

[source,elm]
----
<<main-functions>>=
port natsSend : Nats.PortsAPI.Send String msg
port natsReceive : Nats.PortsAPI.Receive String msg

natsConfig : Nats.Config String String Msg
natsConfig =
    Nats.Config.string NatsMsg
        { send = natsSend
        , receive = natsReceive
        }
        |> Nats.Config.withDebug False
----

==== receiveProg [[main-recieve-prog]]

This maps a `Nats` subscription event to an `Elm` event, allowing us to handle
data messages in the UI.

(((main,functions,receiveProg)))

[source,elm]
----
<<main-functions>>=
receiveProg : Nats.Protocol.Message String -> Msg
receiveProg natsMessage =
    ReceiveProg natsMessage.data
----

==== natsSubscriptions [[main-nats-subscriptions]]

This subscription allows us to make the connection, which must match the
configuration used by the `nats` server. We also subscribe to incoming
`Wets.client` messages and direct them to the
<<main-recieve-prog,recieveProg>> function for processing.

(((main,functions,natsSubscriptions)))

[source,elm]
----
<<main-functions>>=
natsSubscriptions : Model -> Nats.Sub String Msg
natsSubscriptions model =
    Nats.Sub.batch
        [ Nats.connect
            (Nats.Socket.connectOptions "Wets UI" "0.1"
                |> Nats.Socket.withUserPass "test" "test"
            )
            model.socket
            OnSocketEvent
        , Nats.subscribe "Wets.client" receiveProg
        ]
----

=== Updates [[main-updates]]

==== wrappedUpdate [[main-wrapped-update]]

(((main,functions,wrappedUpdate)))

[source,elm]
----
<<main-functions>>=
wrappedUpdate : Msg -> Model -> ( Model, Cmd Msg )
wrappedUpdate msg model =
    let
        ( newModel, natsEffect, cmd ) =
            update msg model

        ( nats, natsCmd ) =
            Nats.applyEffectAndSub
                natsConfig
                natsEffect
                (natsSubscriptions model)
                newModel.nats
    in
    ( { newModel | nats = nats }
    , Cmd.batch [ cmd, natsCmd ]
    )
----

==== update [[main-update]]

The `update` function translates a <<main-msg,Msg>> into an activity that is
likely to cause a change in the <<main-view,view>>. For each `Msg` there will
be a corresponding <<main-update,update>> case. Literate programming allows us
to itemize these messages next to their update functionality.

[source,elm]
----
<<main-functions>>=
update : Msg -> Model -> ( Model, Nats.Effect String Msg, Cmd Msg )
update msg model =
    case msg of
        <<main-update-case>>
----

NOTE: The return value includes a `Nats.Effect` which is a departure from the
standard Elm architecture due to the <<main-wrapped-update,wrapped update>>
which got us here.

==== Msg [[main-msg]]

A core part of the Elm Architecture, the `Msg` type defines the actions that
can change the state `model`.

(((Main,types,Msg)))

[source,elm]
----
<<main-types>>=
type Msg
    <<main-messages>>
----


==== AnimationRuntimeStep [[main-animator-runtime-step]]

This is the animation frame tick which is used to update the
<<main-animator,Animator>> instance.

[source,elm]
----
<<main-messages>>=
= AnimationRuntimeStep Time.Posix
----

(((main,functions,update)))

[source,elm]
----
<<main-update-case>>=
AnimationRuntimeStep tick ->
    ( Animator.update tick animator model
    , Nats.Effect.none
    , Cmd.none
    )
----


==== OnMenuSelect

This is a generic message for when a menu is selected. One use for this is to
capture the selected population name.


[source,elm]
----
<<main-messages>>=
| OnMenuSelect String
----

[source,elm]
----
<<main-update-case>>=
OnMenuSelect menuEntry ->
    ( { model | wetsPopname = menuEntry}
      , Nats.Effect.none
      , Cmd.none
    )
----

==== MenuButtonMsg

This is used to coordinate the menu activity state.

[source,elm]
----
<<main-messages>>=
| MenuButtonMsg String (OUI.MenuButton.Msg String Msg)
----

[source,elm]
----
<<main-update-case>>=
MenuButtonMsg id menuMsg ->
    case id of
        "popmenu" ->
            let
                ( state, cmd ) = OUI.MenuButton.update menuMsg model.popState
            in
            ( { model | popState = state }
              , Nats.Effect.none
              , cmd
            )
        _ ->
            ( model
            , Nats.Effect.none
            , Cmd.none )
----


==== MoveVessel [[main-move-vessel]]

[source,elm]
----
<<main-messages>>=
| MoveVessel Id Int
----

Move a vessel from its current position to the next position in its sequence.
The move will take the given amount of milliseconds. There is very little
error recovery here because we expect the state transition to be correct from
the WETS model.

Both `vesselState` and `activeVessels` dictionaries are updated to reflect the
move to the new `TransitState`.

If the next state in the sequence is at either entry point it means that the
vessel is completing its transit through the lock system. This will
precipitate a `VesselFinished` message being delivered for this vessel after
it completes its move.

[source,elm]
----
<<main-update-case>>=
MoveVessel license millis ->
    case nextTransition license model.activeVessels of
        Nothing ->
            ( { model
                | message =
                    "handleVessel: No next transit state for " ++ license
              }
            , Nats.Effect.none
            , Cmd.none
            )

        Just nextState ->
            let
                setVesselState : TransitState -> Dict Id TransitState
                setVesselState newState =
                    Dict.insert license newState
                    <| Animator.current model.vesselStates
            in
            ( { model
                | vesselStates = model.vesselStates
                    |> Animator.go (Animator.millis <| toFloat millis)
                         (setVesselState nextState)
                , activeVessels =
                    adjustSequence license model.activeVessels
              }
            , Nats.Effect.none
            , if nextState == LowerEntry || nextState == UpperEntry
              then
                  Delay.after millis <| VesselFinished license
              else
                  Cmd.none
            )
----


==== VesselFinished [[main-vessel-finished]]

This state has the important role of keeping the active vessel dictionary in
sync with the vessels present in the `Animator's` vessel states.

[source,elm]
----
<<main-messages>>=
| VesselFinished Id
----

[source,elm]
----
<<main-update-case>>=
VesselFinished id ->
    ( { model
          | activeVessels = Dict.remove id model.activeVessels
          , vesselStates = model.vesselStates
              |> Animator.go Animator.immediately
                 (Dict.remove id <| Animator.current model.vesselStates)
         , message = "Finished \"" ++ id ++ "\""
      }
    , Nats.Effect.none
    , Cmd.none
    )
----


==== VesselPassedGate [[main-vessel-passed-gate]]

This update is called whenever a vessel has been directed to move past a gate.

[source,elm]
----
<<main-messages>>=
| VesselPassedGate Id
----

[source,elm]
----
<<main-update-case>>=
VesselPassedGate id ->
    ( model
    , Nats.publish "Wets.1" <| Wets.vesselPassedGate id
    , Cmd.none
    )
----


==== FlowComplete [[main-flow-complete]]

[source,elm]
----
<<main-messages>>=
| FlowComplete Id
----

[source,elm]
----
<<main-update-case>>=
FlowComplete id ->
    ( model
    , Nats.publish "Wets.1" <| Wets.flowEqualized id
    , Cmd.none
    )
----


==== ActuatorMoveDone [[main-actuator-move-done]]

[source,elm]
----
<<main-messages>>=
| ActuatorMoveDone Id
----

[source,elm]
----
<<main-update-case>>=
ActuatorMoveDone id ->
    ( model
    , Nats.publish "Wets.1" <| Wets.actuatorMoveDone id
    , Cmd.none
    )
----


==== StartVessel [[main-start-vessel]]

[source,elm]
----
<<main-messages>>=
| StartVessel Util.Direction
----

Start a vessel on its <<main-transit-sequence,TransitSequence>>.

. A <<main-new-vessel,new Vessel>> is created.
. A license is assigned to the vessel which will be used as key in the
<<main-model,activeVessels>> dictionary.
. The start state is pulled from its `transitSequence`.
. The start state is inserted into the <<main-animator,animator>> for this
vessel.

Following that,

* The model is updated with an incremented vessel count.
* The <<main-animator,vesselStates>> is updated to be at this start state
  immediately.
* The active vessels dictionary is updated by purging finished vessels and
  inserting the new vessel.
* Notice of the arriving vessel is sent to WETS.
* The <<main-move-vessel,MoveVessel>> command is sent to
  <<main-update,update>> after a brief delay.

[source,elm]
----
<<main-update-case>>=
StartVessel direction ->
    case newVessel model.wetsPopname direction of
        Nothing ->
            ( { model
                  | message = "Internal: Failed vessel start!"
              }
            , Nats.Effect.none
            , Cmd.none
            )
        Just vessel ->
            let
                license : String
                license =
                    Util.newVesselName model.vesselCount

                startState : TransitState
                startState =
                    vessel.sequence |> List.head |> Maybe.withDefault AtSea

                startVessel : Dict Id TransitState
                startVessel =
                    Animator.current model.vesselStates
                        |> Dict.insert license startState
            in
            ( { model
                | vesselCount = model.vesselCount + 1
                , vesselStates =
                    model.vesselStates
                        |> Animator.go Animator.immediately startVessel
                , activeVessels =
                    model.activeVessels
                        |> Dict.insert license
                            { vessel | sequence = List.drop 1 vessel.sequence }
                , message =
                    "Starting vessel \"" ++ license ++ "\""
              }
            , Nats.publish "Wets.1" <|
                Wets.startVessel model.wetsPopname license <|
                    Util.toString direction
            , Delay.after 100 <| MoveVessel license 1000
            )
----


==== NatsMsg

When a `NatsMsg` arrives, the `NATS` model is updated which may result in
a message delivery to our model.

[source,elm]
----
<<main-messages>>=
| NatsMsg (Nats.Msg String Msg)
----

[source,elm]
----
<<main-update-case>>=
NatsMsg natsMsg ->
    let
        ( nats, natsCmd ) =
            Nats.update natsConfig natsMsg model.nats
    in
    ( { model | nats = nats }
    , Nats.Effect.none
    , natsCmd
    )
----

==== OnSocketEvent

[source,elm]
----
<<main-messages>>=
| OnSocketEvent Nats.Events.SocketEvent
----

Update the model's `serverInfo` structure on a socket event.
There are a number of details in the `info` structure that might be
interesting to the user.

[source,elm]
----
<<main-update-case>>=
OnSocketEvent event ->
    ( { model
        | serverInfo =
            case event of
                Nats.Events.SocketOpen info ->
                    Just info
                _ ->
                    Nothing
      }
    , Nats.Effect.none
    , Cmd.none
    )
----


==== ReceiveProg

This message arrives when a `Wets.client` message is received via NATS, the
handling of which is deferred to the <<main-wets-hander,wetsHandler>>
function.

[source,elm]
----
<<main-messages>>=
| ReceiveProg String
----

[source,elm]
----
<<main-update-case>>=
ReceiveProg data ->
    let
        ( new_model, cmd ) = wetsHandler data model
    in
    ( new_model
    , Nats.Effect.none
    , cmd
    )
----


==== wetsHandler [[main-wets-handler]]

Handle incoming `Wets.client` messages based on their
<<wets-message-type,messageType>> so that,

<<main-handle-motor,handleMotor>>:: handles `Motor` messages.
<<main-handle-flow,handleFlow>>:: for `Flow` messages.
<<main-handle-vessel,handleVessel>>:: for `Vessel` messages.

To accomplish this, `Json.Decode` is needed for the decode function but an
appropriate decoder from the `Wets` module is used for the hard work.

[source,elm]
----
<<main-imports>>=
import Json.Decode as Decode
----

(((main,functions,wetsHandler)))

[source,elm]
----
<<main-functions>>=
wetsHandler : String -> Model -> ( Model, Cmd Msg )
wetsHandler data model =
    case Wets.messageType data of
        Just Wets.MotorMsg ->
            case Decode.decodeString Wets.motorDecoder data of
                Ok cmd -> handleMotor model cmd
                Err e ->
                    ( { model | message = Decode.errorToString e }
                    , Cmd.none
                    )

        Just Wets.FlowMsg ->
            case Decode.decodeString Wets.flowDecoder data of
                Ok cmd -> handleFlow model cmd
                Err e ->
                    ( { model | message = Decode.errorToString e }
                    , Cmd.none
                    )

        Just Wets.VesselMsg ->
            case Decode.decodeString Wets.vesselDecoder data of
                Ok cmd -> handleVessel model cmd
                Err e ->
                    ( { model | message = Decode.errorToString e }
                    , Cmd.none
                    )

        Nothing ->
            ( model, Cmd.none )
----


==== handleVessel [[main-handle-vessel]]

(((main,functions,handleVessel)))

There is only a single vessel command -- MOVE -- so this results in a
<<main-move-vessel,MoveVessel>> command. Vessels are instructed to MOVE when
they are ready to pass through a gate so the returning command is set as a
sequence to send the appropriate message when it completes.


[source,elm]
----
<<main-functions>>=
handleVessel : Model -> Wets.VesselCommand -> ( Model, Cmd Msg )
handleVessel model cmd =
    ( model
    , Delay.sequence
        [ ( 0, MoveVessel cmd.license 1000 )
        , ( 1000, VesselPassedGate cmd.license )
        ]
    )
----


(((main,imports,Delay)))

[source,elm]
----
<<main-imports>>=
import Delay
----

==== Handling flow [[main-handling-flow]]

(((main,functions,handleFlow)))

This command is received when a valve has been opened that will result in
manipulating the level of water in a chamber. There may or may not be vessels
in the chamber. For a *Wets_1* layout -- 1 chamber, 2 gates -- the reactions
on the chamber are straightforward. Open the lower valve and the sole chamber
will drain, Open the upstream valve and it will fill.

It is somewhat more complicated with a *Wets_2* layout, as shown in
<<main-flow-reaction-table,the following diagram>>, which shows a *Wets_2* layout that has 3 gates
forming 2 chambers.

.Chamber layout for Wets_2 [[main-flow-reaction-table]]
image::wets-2-layout.svg[role=center]

The upstream and downstream reactions are similar to *Wets_1* but special care
must be taken with the center chamber.

.Flow Sensor reactions [[main-flow-sensor-reactions]]
[cols="1,2,2,1",options="header",width="80%",role=center]
|===
| Population | Flow Sensor | Affected Chamber | State

.2+| Wets_1
| Sensor-F01 | AChamber | Low

| Sensor-F02 | AChamber | High

.4+| Wets_2
| Sensor-F03 | AChamber | Low

.2+|Sensor-F04
| AChamber | High
| BChamber | Low

| Sensor-F05 | BChamber | High
|===

The name of the sensor can be used to derive the target `Chamber` and its
target states. The target chamber state (`cstate`) is used in the
chamber animation. The target transit state (`tstate`) is used to build a list
of possible vessel moves that are sequenced after the model is updated.

.inChamberP [[main-inChamber-p]]
This is a predicate that returns true if a transit state is within a chamber.

(((Main,main-functions,inChamberP)))

[source,elm]
----
<<main-functions>>=
inChamberP : TransitState -> Bool
inChamberP tstate =
    case tstate of
        AChamberHigh -> True
        AChamberLow  -> True
        BChamberHigh -> True
        BChamberLow  -> True
        _ -> False
----

.chamberMoves [[main-chamber-moves]]

Given a sensor identifier, return a list of chamber states.
Refer to the
<<main-flow-sensor-reactions,flow reactions table>> for details on the
contents of these lists.

[source,elm]
----
<<main-functions>>=
chamberMoves : String -> Dict Id ChamberState
chamberMoves sensor =
    Dict.fromList <|
        case sensor of
            "Sensor-F01" ->
                [ ( "AChamber", Low ) ]

            "Sensor-F02" ->
                [ ( "AChamber", High ) ]

            "Sensor-F03" ->
                [ ( "AChamber", Low ) ]

            "Sensor-F04" ->
                [ ( "AChamber", High )
                , ( "BChamber", Low )
                ]

            "Sensor-F05" ->
                [ ( "BChamber", High ) ]

            _ ->
                []
----

.handleFlow [[main-handle-flow]]

Once a valve has been open it is necessary to inform the WETS model that flow
has equalized between the two bodies of water on either side of the gate. This
function takes into account,

* There may or may not be vessels in the chambers.

* Chambers typically fill slowly so these should be timed longer than simple
  moves through a gate.

NOTE: This function uses a _union_ of two dictionaries to update the
`chamberStates` dictionary. This makes it trivial to update more than one
chamber in a single call of flow handling.


(((Main,functions,handleFlow)))

[source,elm]
----
<<main-functions>>=
handleFlow : Model -> Wets.FlowCommand -> ( Model, Cmd Msg )
handleFlow model cmd =
    let
        updateChambers : Id -> Dict Id ChamberState
        updateChambers sensor =
            Animator.current model.chamberStates
                |> Dict.union (chamberMoves sensor)

        vMoves : List ( Int, Msg )
        vMoves =
            Animator.current model.vesselStates
                |> Dict.filter (\_ v -> inChamberP v)
                |> Dict.keys
                |> List.map (\vid -> ( 0, MoveVessel vid 2000 ))
    in
    ( { model
        | chamberStates =
            model.chamberStates
                |> Animator.go (Animator.millis 2000)
                    (updateChambers cmd.name)
      }
    , Delay.sequence <|
        List.append vMoves <|
            List.singleton ( 2000, FlowComplete cmd.name )
    )
----


==== handleMotor [[main-handle-motor]]

Valve and gate motors are both handled here.

(((main,functions,handleMotor)))

[source,elm]
----
<<main-functions>>=
handleMotor : Model -> Wets.MotorCommand -> ( Model, Cmd Msg )
handleMotor model cmd =
    let
        opAsState : String -> ActuatorState
        opAsState op =
            if op == "RUN_IN" then
                Closed
            else
                Opened

        setActuator : Id -> ActuatorState -> Dict Id ActuatorState
        setActuator id newState =
            Dict.insert id newState
                 <| Animator.current model.actuatorStates

        actState : ActuatorState
        actState =
            opAsState cmd.operation
    in
    ( { model
        | actuatorStates = model.actuatorStates
            |> Animator.go (Animator.millis 1000)
                (setActuator cmd.name actState)
      }
    , Delay.after 1000 <| ActuatorMoveDone cmd.name
    )
----

=== View

When any graphical bit changes in the model, the `view` function is called to
change the graphics presented to the user. This might appear to be an immense
amount of work in a UI with animated graphics, but the work being done here
updates the Domain Object Model (DOM) and then ... magic happens to update the
screen.

Because of all the layout work a view function can be quite large so it is
broken out into a number of parts.

<<main-view,view>>:: The main entry point for view functionality.
<<main-locks,locks>>:: The graphical depiction of a canal lock.
<<main-start-panel>>:: The left-side button controls.
<<main-info-panel>>:: The ServerInfo panel that has morphed to a simple
Offline/Online graphic.

==== view [[main-view]]

(((main,functions,view)))

[source,elm]
----
<<main-functions>>=
view : Model -> Browser.Document Msg
view model =
    { title = "Sim Proto"
    , body =
        [ UI.layout <|
            E.column
                [ E.paddingEach
                    { top = 40, right = 0, bottom = 0, left = 80 }
                ]
                [ E.row
                    [ E.spacing 20
                    , E.paddingEach { top = 0, right = 0, bottom = 0, left = 30} ]
                    [ Text.displayMedium "WETS"
                        |> Material.text UI.theme
                    , wetsMenu model
                    ]
                , E.row
                    [ E.paddingEach
                        { top = 20, right = 0, bottom = 60, left = 20 }
                    , E.spacing 20
                    ]
                    [ startPanel
                    , E.el
                        [ E.width <| E.px 600
                        , E.height <| E.px 200
                        ] <| locks model
                    ]
                , E.row
                    [ E.paddingEach
                        { top = 0, right = 0, bottom = 0, left = 20 }
                    , E.spacing 20
                    ]
                    [ infoPanel model
                    , Text.bodyMedium model.message
                        |> Material.text UI.theme
                    ]
                ]
        ]
    }
----



==== locks [[main-locks]]

The `locks` function composes an SVG view of a canal lock containing,

* two animated gates
* two animated valves
* an animated center chamber

SVG is z-layered. After defining a 600X200 pixel view the components are built
up within that.

* A light-colored background _sky_.
* The chambers are filled rectangles to represent water, the center one is
  animated.
* The gate is a darker rectangle whose opacity is animated.
* The valve is a hub and vane combination in which the vane is animated.
* Finally the vessels are animated on top of all that.

NOTE: When *Wets_2* support was added, the construction of the lock was
separated into two lists of lock graphics to make switching between one and
the other simpler.

(((main,functions,locks)))

[source,elm]
----
<<main-functions>>=
locks : Model -> E.Element msg
locks model =
    let
        lock =
            case model.wetsPopname of
                "Wets_1" ->
                    lockOne model
                "Wets_2" ->
                    lockTwo model
                _ -> []
    in
    Svg.svg
        [ SvgA.viewBox "0 0 600 200"
        , SvgA.width "600"
        , SvgA.height "200"
        ]
        (List.concat [
             [ Svg.rect
                   [ SvgA.width "600"
                   , SvgA.height "200"
                   , SvgA.x "0"
                   , SvgA.y "0"
                   , SvgA.fill <| Color.toCssString Color.lightGray
                   ]
                   []
             ]
            , lock
            , allVessels model
            ])
        |> E.html
----

.lockOne, a  lock for Wets_1 [[main-lockOne]]

(((Main,functions,lockOne)))

[source,elm]
----
<<main-functions>>=
lockOne : Model -> List (Svg msg)
lockOne model =
    [ UI.chamber 200 0 40
    , animChamber "AChamber" model 200 200
    , UI.chamber 200 400 80
    , animGate "Gate-M02" model 194 34 90
    , UI.hub 200 148
    , animVane "Valve-M02" model 200 148
    , animGate "Gate-M01" model 394 34 90
    , UI.hub 400 148
    , animVane "Valve-M01" model 400 148
    , Svg.polygon
          [ SvgA.points "0,150 200,170 600,170 600,200 0,200"
          , SvgA.fill <| Color.toCssString Color.darkBrown
          ]
          []
    ]
----

.lockTwo, a lock for Wets_2 [[main-lockTwo]]

(((Main,functions,lockTwo)))

[source,elm]
----
<<main-functions>>=
lockTwo : Model -> List (Svg msg)
lockTwo model =
    [ UI.chamber 150 0 40
    , animChamber "BChamber" model 150 150
    , animChamber "AChamber" model 150 300
    , UI.chamber 450 300 120
    , animGate "Gate-M05" model 144 30 90
    , UI.hub 150 146
    , animVane "Valve-M05" model 150 146
    , animGate "Gate-M04" model 294 30 110
    , UI.hub 300 165
    , animVane "Valve-M04" model 300 165
    , animGate "Gate-M03" model 444 60 90
    , UI.hub 450 175
    , animVane "Valve-M03" model 450 175
    , Svg.polygon
          [ SvgA.points "0,150 150,170 300,188 450,200 0,200"
          , SvgA.fill <| Color.toCssString Color.darkBrown
          ]
          []
    ]
----

==== startPanel [[main-start-panel]]

This forms the start controls that can introduce vessels into the system.
Keypresses are directed to the <<main-start-vessel,StartVessel>> command.

(((main,functions,startPanel)))

[source,elm]
----
<<main-functions>>=
startPanel : E.Element Msg
startPanel =
    let
        scheme : OUI.Material.Color.Scheme
        scheme =
            OUI.Material.Theme.colorscheme UI.theme
    in
    E.column
        [ Border.rounded 12
        , Border.color <|
            OUI.Material.Color.toElementColor scheme.outlineVariant
        , Border.width 1
        , Background.color <|
            OUI.Material.Color.toElementColor scheme.primaryContainer
        , E.padding 20
        , E.spacing 20
        , E.height E.fill
        ]
        [ "Start Vessel"
            |> Text.bodyMedium
            |> Material.text UI.theme
        , Button.new "Downstream"
            |> Button.onClick (StartVessel Util.Downstream)
            |> Material.button UI.theme []
        , Button.new "Upstream"
            |> Button.onClick (StartVessel Util.Upstream)
            |> Material.button UI.theme [ E.width E.fill ]
        ]
----



==== infoPanel [[main-info-panel]]

This shows the state of the NATS connection. This has the potential of being
more elaborate but a simple green/red display is used here.

(((main,functions,infoPanel)))

[source,elm]
----
<<main-functions>>=
infoPanel : Model -> E.Element msg
infoPanel model =
    let
        isOnline : Bool
        isOnline =
            case model.serverInfo of
                Nothing -> False
                Just _ -> True

        panelAttr : List (E.Attribute msg)
        panelAttr =
            if isOnline then
                [ Background.color <| E.rgb255 0x1b 0x82 0x2f
                ]
            else
                [ Background.color <|
                    OUI.Material.Color.toElementColor scheme.errorContainer
                ]

        scheme : OUI.Material.Color.Scheme
        scheme = OUI.Material.Theme.colorscheme UI.theme
    in
    E.el
        ([ Border.rounded 10
         , Border.color <|
            OUI.Material.Color.toElementColor scheme.outlineVariant
         , Border.width 1
         , E.paddingEach { left = 18, top = 6, right = 10, bottom = 6 }
         , E.width <| E.px 100
         ] ++ panelAttr
        )
    <|
        Material.text UI.theme <|
            Text.bodyMedium <|
                if isOnline then
                    "Online"

                else
                    "Offline"
----

=== Animation

The following functions implement animated bits in the <<main-lock,lock>>
function.

<<main-anim-vane,Vane animation>>:: The moving part of the valve depiction.
<<main-anim-chamber,Chamber animation>>:: The chamber resized its height to
simulate filling or draining of a chamber.
<<main-anim-gate,Gate animation>>:: The gate changes visually when opened or
closed.
<<main-all-vessels,Vessels>>:: All active vessels are checked for animation.


==== animVane [[main-anim-vane]]

Only the vane of the valve is animated. This makes a quarter circle rotation
to represent open (Ï€/2) or closed (0).

This animates a single vane for the actuator with the given `Id`.

(((main,functions,animVane)))

[source,elm]
----
<<main-functions>>=
animVane : Id -> Model -> Int -> Int -> Svg msg
animVane id model x y =
    let
        valveValue : ActuatorState -> Float
        valveValue astate =
            case astate of
                Opened -> pi / 2.0
                Closed -> 0.0
    in
    UI.vane x y
    <| Animator.linear model.actuatorStates <|
        \actuatorStates ->
            Animator.at <|
                case Dict.get id actuatorStates of
                    Just astate -> valveValue astate
                    Nothing -> 0.0
----



==== animChamber [[main-anim-chamber]]

Animating a chamber is a matter of manipulating the Y coordinate in the
appropriate direction.

* The `Id` of the chamber is passed in so we can find it in our chamber state
  dictionary

* The `Model` is needed since that holds the `chamberStates`.

* The fixed `xoffset` is passed in.

* The <<main-chamber-state,chamber depth>> is given by the depth associated
  with the state.

(((main,functions,animChamber)))

This local function provides an association between a `ChamberState` and its
depth in an SVG glyph. You can thank the SVG coordinate system for any
confusion about the value for `High` being lower than the value for `Low`.

NOTE: This got slightly more complex when an additional chamber was supported
for *Wets_2*.

[source,elm]
----
<<main-functions>>=
animChamber : Id -> Model -> Int -> Int -> Svg msg
animChamber id model width xoffset =
    let
        chamberDepth : ChamberState -> Float
        chamberDepth cstate =
            case cstate of
                High -> 40.0
                Low -> 80.0
        ySurface : Float
        ySurface =
            if model.wetsPopname == "Wets_2" && id == "AChamber"
            then
                40.0
            else
                0.0
    in
    UI.chamber width xoffset <|
        round <|
            Animator.linear model.chamberStates <|
                \chamberStates ->
                    Animator.at <|
                        case Dict.get id chamberStates of
                            Just cs ->
                                ySurface + (chamberDepth cs)
                            Nothing ->
                                0.0
----


==== animGate [[main-anim-gate]]

Animating a gate is tricky since the side view will look like a large slab
and the vessel will be hidden behind it as it passes through.
Here the opacity of the gate is animated so it transitions from
fully opaque to almost transparent.

(((main,functions,animGate)))

[source,elm]
----
<<main-functions>>=
animGate : Id -> Model -> Int -> Int -> Int -> Svg msg
animGate id model x y height =
    let
        gateOpacity : ActuatorState -> Float
        gateOpacity astate =
            case astate of
                Opened -> 0.25
                Closed -> 1.0
    in
    UI.gate x y height
    <| Animator.linear model.actuatorStates <|
        \actuatorStates ->
            Animator.at <|
                case Dict.get id actuatorStates of
                    Just gstate -> gateOpacity gstate
                    Nothing -> 0.0
----


==== animVessel [[main-anim-vessel]]

Vessel animation is interesting because it moves in both X and Y. All the
animations are linear and, for some reason, this `xy` animator has some easing
to it. Since it may be that the vessel being animated is in a chamber with a
changing water level, this easing is zeroed in `y` to force a linear motion.

(((main,functions,animVessel)))

[source,elm]
----
<<main-functions>>=
animVessel : Id -> Model -> Util.Direction -> Svg msg
animVessel id model direction =
    case Dict.get model.wetsPopname wetsPop of
        Nothing ->
            Svg.text ""
        Just strategy ->
            UI.vessel id direction <|
                Animator.xy model.vesselStates <|
                    \vStates ->
                        let
                            xypos : Util.Position
                            xypos =
                                Dict.get id vStates
                                    |> Maybe.withDefault AtSea
                                    |> strategy.toPosition
                        in
                        { x = Animator.at xypos.x
                        , y =
                            Animator.at xypos.y
                                |> Animator.leaveSmoothly 0
                                |> Animator.arriveSmoothly 0
                        }
----


==== allVessels [[main-all-vessels]]

This is a view function for displaying all active vessels.

(((main,functions,allVessels)))

[source,elm]
----
<<main-functions>>=
allVessels : Model -> List (Svg msg)
allVessels model =
    model.activeVessels
        |> Dict.toList
        |> List.map
           (\t -> animVessel (Tuple.first t)
                model
                (Tuple.second t).direction)
----

==== wetsMenu [[main,wets-menu]]

[source,elm]
----
<<main-functions>>=
wetsMenu : Model -> E.Element Msg
wetsMenu model =
    OUI.MenuButton.new
        (MenuButtonMsg "popmenu")
        (OnMenuSelect)
        (Button.new
             model.wetsPopname |> Button.outlinedButton
        )
        (OUI.Menu.new identity
             |> OUI.Menu.addItems [ "Wets_1", "Wets_2" ]
             |> OUI.Menu.withIcon
                 (\i ->
                     if i == model.wetsPopname then
                         Just Icon.check
                     else
                         Nothing
                 )
        )
        |> OUI.MenuButton.withOpenCloseIcons
           Icon.arrow_drop_down Icon.arrow_drop_up
        |> Material.menuButton UI.theme model.popState []
----

=== Code Layout

[source,elm]
----
<<Main.elm>>=
<<main-module>>

<<main-imports>>

<<main-types>>

<<main-literals>>

<<main-functions>>
----
